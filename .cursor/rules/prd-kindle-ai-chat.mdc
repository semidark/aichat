---
description: 
globs: 
alwaysApply: true
---
# Product Requirements Document  
### Kindle AI Chat (aichat-kindle Edition)

## 1. Introduction / Overview
The goal is to develop a simple yet powerful AI-chat web interface optimized for low-power devices—specifically, the Kindle e-reader’s web browser.  

Kindle AI Chat is a fork-based adaptation of the open-source project **sigoden/aichat**, purpose-built for the low-power web browser found on Kindle e-readers (FW 5.16.4 +).  
By leveraging aichat’s well-tested crates and architecture, we will deliver a lightweight, snappy chat experience on e-ink while keeping long-term parity with upstream improvements.

Key characteristics
* Rust backend on Rocket (mirrors aichat’s Rust foundations).
* Hypermedia frontend driven by htmx (minimal ES5-only JavaScript).
* AI inference, session logic, and streaming powered by aichat’s `@client` and related crates.

The first release focuses on a lean, fast, and responsive chat experience for resource-constrained clients with e-ink displays. Later iterations will add document-chat (RAG) capabilities via aichat’s `@rag` implementation.

---
### 1-A. Code Reuse & Forking Strategy
1. **Project Fork** – Development begins with a fork of `github.com/sigoden/aichat` under the working name `aichat-kindle`.  
2. **Module Reuse**  
   • **Clarity on Code Reuse:** The approach explicitly differentiates between unchanged components and those requiring adaptation. Unmodified modules such as the `@client` crate, conversation history structures, and logging utilities will be reused without alteration. In contrast, components that interact directly with the server bootstrap or user interface – especially those that need tailoring for the Kindle’s e-ink display and hyper features – will be carefully adapted.  
   • Adapt: server bootstrap will be modified to use Rocket while the HTTP client functionality in aichat (which uses Hyper, not axum) will be acknowledged and interfaced accordingly.  
3. **Upstream Compatibility** –  
   • Keep crate boundaries identical wherever possible.  
   • Submit generic improvements back to the upstream repo.  

---

## 2. Goals
* **Performance** – Extremely lightweight interface that feels snappy on the Kindle browser.  
* **Codebase Reusability** – Maximise reuse of aichat code to accelerate delivery and simplify future maintenance.  
* **User Experience (UX)** – Smooth, chunked streaming optimised for slow e-ink refresh.  
* **Extensibility** – The fork must stay structurally compatible with upcoming aichat features (e.g., `@rag`, model selection).  
* **Developer Velocity** – On-device debug console for rapid iteration.

---

## 3. User Stories
* **Core Interaction** – As a Kindle user, I can open the page and start chatting immediately—no login or setup.
* **Conversation Continuity** – My chat history persists across visits via cookie-keyed sessions.
* **E-Ink-Optimised Streaming** – Replies appear in smooth, reasonably sized chunks.
* **Developer Debugging** – I can toggle a console to view logs directly on Kindle.
* **Simplified Workflow** – The UI is clean and simple.

---

## 4. Functional Requirements

### 4.1 Backend (Rocket Server)
1. **Serve Interface** – Single `index.html` (forked from aichat’s template, Kindle-tuned).
2. **Chat Endpoint** – `POST /chat` receives user input and streams response.
3. **LLM Integration** – Use aichat’s `@client` crate (and any future shared crates) for model calls.
4. **Persistent Sessions**
   * Generate UUID cookie on first visit.
   * Store conversation JSON on disk under `data/{uuid}.json` (same schema as aichat).
5. **Configurable Streaming**
   * Chunk size & delay in `Rocket.toml` (env-var overridable).
   * Defaults tuned for Kindle (e.g., 24 chars, 300 ms).
6. **Logging & Debug Export** – Mirror aichat log format; expose `/logs?tail` SSE for client console.

### 4.2 Frontend (htmx on Kindle Browser)
1. **Minimalist UI**  
   * Scrollable history pane (plain text v1).
   * Resizable `<textarea>` + submit button.
2. **htmx Interactions** – Forms POST to `/chat`; response streamed and appended.
3. **Stream Handling** – JavaScript (ES5) concatenates server-sent `<span>` chunks to history.
4. **Debug Console** – Toggle pane fetches `/logs?tail` via EventSource.
5. **Kindle Compatibility** – ES5 only, no flexbox/grid, high-contrast CSS ≤ 5 KB.

---

## 5. Non-Goals (MVP)
* Authentication & multi-user accounts.
* Multiple chat tabs/branches.
* UI model selection. 
* Message editing/deletion.
* RAG (document chat).

---

## 6. Design & Technical Considerations
* **High-Contrast UI** – Large serif font (18 px), 1.4 line-height for e-ink clarity.
* **Framework Choices** – Rocket is chosen for its ergonomic async streaming; this aligns with the Rust ecosystem and is easy to graft onto aichat logic. Note that while aichat’s HTTP client uses Hyper for its web requests, our fork adapts the server bootstrap to work seamlessly with Rocket.
* **Separation of Concerns:**  
   • The system is designed to clearly separate the customization for Kindle constraints from core functionalities inherited from aichat.  
   • Modifications such as changes to the server bootstrap and HTML templates are kept isolated, ensuring that changes from the upstream codebase can be integrated with minimal conflict.  
   • Custom adaptations (e.g., tailored streaming logic and debug log exposure) are implemented in separate modules to maintain a clean boundary between reused components and Kindle-specific features.
* **JavaScript Constraints** – Kindle WebKit ≈ Safari 5: stick to ES5 and DOM-1 APIs.
* **Styling Footprint** – `<1 KB` critical CSS; no external fonts.
* **Configuration Management** – `Rocket.toml` with `KINDLE_*` env override.  
* **Upstream Sync** – Keep crate namespaces identical to aichat to minimise merge friction.

---

## 7. Success Metrics
* ≤ 2 s to interactive on Kindle Paperwhite 11th Gen.
* ≥ 95 % of streamed chunks arrive without visible Flash/Flicker artifacts.  
* Session history persists after browser restart (verified across 20 test runs).
* Debug console displays latest 100 log lines with < 200 ms lag.

---

## 8. Testing and CI Integration
* A comprehensive test suite, including unit tests, integration tests, and end-to-end tests, will be established to cover both the inherited functionality and the Kindle-specific adaptations.  
* Continuous Integration (CI) pipelines will be set up to run tests on every commit, as well as to build and deploy changes on test devices or simulators that mimic the Kindle's web browser environment.  
* Performance benchmarks specific to low-power, e-ink devices will be integrated into the CI process to ensure that response times, memory footprint, and CPU usage meet the success metrics.
* Automated testing scripts will help verify that merging upstream changes does not break the customized modifications, bolstering confidence in long-term maintainability.

---

## 9. Dependencies and Versioning

This project will use the upstream aichat’s `Cargo.toml` as the single source of truth for all dependency versions and library choices. No dependency version numbers will be redundantly documented here.

Guidelines:
1. Reuse the versions and libraries as specified in the upstream `Cargo.toml` for all core functionalities.
2. Do not introduce new libraries for features already covered by existing dependencies.
3. Any deviation or addition must be justified, documented, and reviewed for compatibility and long-term maintainability.
4. Regularly synchronize with upstream to ensure continued compatibility.

By anchoring all dependency management and versioning to the upstream `Cargo.toml`, we ensure maximal compatibility, avoid duplication, and simplify long-term maintenance.

For the libraries we will introduce, we will use the following versions:
- [rocket 0.5.1](mdc:https:/docs.rs/rocket/latest/rocket)
- [uuid 1.17.0](mdc:https:/docs.rs/uuid/1.17.0/uuid)
- [htmx 1.9.12](mdc:https:/htmx.org/docs/v1.9.12) 
  (not 2.x since I want to use the very mature version)
- [aichat v0.29.0](mdc:https:/docs.rs/aichat/0.29.0/aichat) 

## 10. Coding Standards and Best Practices

This fork will follow coding standards and best practices inspired by aichat, which relies on established Rust community conventions, idiomatic code, and clear inline documentation—rather than project-specific, documented guidelines.

The following best practices should be observed:

1. **Style Guidelines and Formatting**
   - Adhere to the official [Rust style guidelines](mdc:https:/doc.rust-lang.org/stable/style-guide/index.html), including naming conventions, indentation, and module structure.
   - Use community-standard formatting and linting tools such as `rustfmt` and `clippy` to maintain code quality and consistency.

2. **Code Modularity and Separation of Concerns**
   - Maintain clear separation between core logic inherited from aichat and modifications introduced for Kindle-specific functionality.
   - Isolate custom adaptations (such as Rocket-based server integration and UI adjustments) in dedicated modules or sub-crates, to simplify upstream merging and minimize conflicts.

3. **Documentation and Inline Comments**
   - Document all public interfaces and modules, following conventions visible throughout aichat’s codebase.
   - Use inline comments to explain complex logic or deviations from upstream functionality, aiding maintainers in understanding Kindle-specific adaptations.

4. **Testing and Quality Assurance**
   - Maintain comprehensive unit and integration tests for new and adapted functionality, using the standard Rust test framework as in aichat.
   - Ensure any new features or changes are accompanied by tests that verify their impact on both core and Kindle-specific features.
   - All tests should be run via CI to enforce standards and prevent regressions.

5. **Review and Collaboration**
   - Code reviews should emphasize adherence to these community conventions and project-specific best practices.
   - If any explicit project-level or community best practices are adopted in the future (either by aichat or this fork), they should be documented and observed.
